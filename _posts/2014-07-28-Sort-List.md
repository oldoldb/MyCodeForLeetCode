---
layout: post
title: Sort List
date: 2014-07-28 15:52:16
disqus: y
---

## 题意：
合并有序链表

## 要求：


## 思路：
模拟合并排序，注意用快慢指针二分

## 代码：

### C++:

{% highlight c++ %}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *merge(ListNode *l,ListNode *r)
    {
        ListNode *temp=new ListNode(0);
        ListNode *p=temp;
        while(l&&r)
        {
            if(l->val<=r->val)
            {
                p->next=l;
                l=l->next;
            }
            else
            {
                p->next=r;
                r=r->next;
            }
            p=p->next;
        }
        if(l==NULL)
        {
            p->next=r;
        }
        else
        {
            p->next=l;
        }
        p=temp->next;
        temp->next=NULL;
        delete temp;
        return p;
    }
    ListNode *mergesort(ListNode *head)
    {
        if(head==NULL || head->next==NULL)
        {
            return head;
        }
        ListNode *p=head;
        ListNode *q=head;
        ListNode *pre=NULL;
        while(q&&q->next)
        {
            q=q->next->next;
            pre=p;
            p=p->next;
        }
        pre->next=NULL;
        return merge(mergesort(head),mergesort(p));
    }
    ListNode *sortList(ListNode *head) {
        if(head==NULL || head->next==NULL)
        {
            return head;
        }
        return mergesort(head);
    }
};


 {% endhighlight %}
### python:

{% highlight python %}

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param head, a ListNode
    # @return a ListNode
    def sortList(self, head):
        if head==None or head.next==None:
            return head
        return self.mergesort(head)
    def mergesort(self,head):
        if head==None or head.next==None:
            return head
        p=head
        q=head
        pre=None
        while q!=None and q.next!=None:
            q=q.next.next
            pre=p
            p=p.next
        pre.next=None
        return self.merge(self.mergesort(head),self.mergesort(p))
    def merge(self,l,r):
        temp=ListNode(0)
        p=temp
        while l!=None and r!=None:
            if l.val<=r.val:
                p.next=l
                l=l.next
            else:
                p.next=r
                r=r.next
            p=p.next
        if l==None:
            p.next=r
        else:
            p.next=l
        p=temp.next
        temp.next=None
        return p
 {% endhighlight %}
