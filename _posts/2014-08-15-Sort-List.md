---
layout: post
title: Sort List
date: 2014-08-15 22:19:16
disqus: y
---

## 题意：
合并有序链表

## 要求：


## 思路：
模拟合并排序，注意用快慢指针二分

## 更新：
总结leetcode链表题目

## 代码：

### C++:

{% highlight c++ %}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *merge(ListNode *l1, ListNode *l2)
    {
        ListNode *shead=new ListNode(0);
        ListNode *p=shead;
        while(l1 && l2)
        {
            if(l1->val<l2->val)
            {
                p->next=l1;
                p=l1;
                l1=l1->next;
            }
            else
            {
                p->next=l2;
                p=l2;
                l2=l2->next;
            }
        }
        if(l1)
            p->next=l1;
        else
            p->next=l2;
        return shead->next;
    }
    ListNode *mergeSort(ListNode *head)
    {
        if(!head || !head->next)
            return head;
        ListNode *p=head;
        ListNode *q=head;
        ListNode *prev=NULL;
        while(q)
        {
            prev=p;
            p=p->next;
            if(!q)
                break;
            q=q->next;
            if(!q)
                break;
            q=q->next;
        }
        prev->next=NULL;
        return merge(mergeSort(head),mergeSort(p));
    }
    ListNode *sortList(ListNode *head) {
        if(!head || !head->next)
            return head;
        return mergeSort(head);
    }
};


 {% endhighlight %}
### python:

{% highlight python %}

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param head, a ListNode
    # @return a ListNode
    def sortList(self, head):
        if head==None or head.next==None:
            return head
        return self.mergesort(head)
    def mergesort(self,head):
        if head==None or head.next==None:
            return head
        p=head
        q=head
        pre=None
        while q!=None and q.next!=None:
            q=q.next.next
            pre=p
            p=p.next
        pre.next=None
        return self.merge(self.mergesort(head),self.mergesort(p))
    def merge(self,l,r):
        temp=ListNode(0)
        p=temp
        while l!=None and r!=None:
            if l.val<=r.val:
                p.next=l
                l=l.next
            else:
                p.next=r
                r=r.next
            p=p.next
        if l==None:
            p.next=r
        else:
            p.next=l
        p=temp.next
        temp.next=None
        return p
 {% endhighlight %}
